# 正则表达式

## （?:pattern）
> 捕获分组但不保存分组。

```js
let sysname = "Window98"
sysname.match(/Window(?:98|95)/)
//结果：['window98', index: 0, input: 'window98', groups: undefined] 分组并没有保存到结果中。
//实际使用：如要配置industry或industries两个单词表达式可以这样写：
let regx = /industr(?:y|ies)/
```
## （?=pattern）
> 正向肯定预查（look ahead positive assert），匹配pattern前面的位置。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。

例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

## (?!pattern)

> 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。

例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

## (?<=pattern)

> 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。

例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。

## (?<!pattern)

>反向否定预查，与正向否定预查类似，只是方向相反。

例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。